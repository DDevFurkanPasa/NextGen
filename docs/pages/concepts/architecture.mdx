# Framework Architecture

Understanding the two-layer architecture that makes Strapi-NextGen Framework maintainable and extensible.

## Overview

Strapi-NextGen Framework is built on a **two-layer architecture** that separates concerns and promotes clean code organization.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Presentation Layer               â”‚
â”‚  (UI Components & Rendering)            â”‚
â”‚                                         â”‚
â”‚  â€¢ StrapiImage                          â”‚
â”‚  â€¢ StrapiRenderer                       â”‚
â”‚  â€¢ Error Boundaries                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚ Uses
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Data Layer                     â”‚
â”‚  (Data Fetching & Caching)              â”‚
â”‚                                         â”‚
â”‚  â€¢ createStrapiSDK                      â”‚
â”‚  â€¢ GraphQL Client                       â”‚
â”‚  â€¢ Cache Management                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚ Fetches from
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Strapi CMS                       â”‚
â”‚  (Content Management)                   â”‚
â”‚                                         â”‚
â”‚  â€¢ GraphQL API                          â”‚
â”‚  â€¢ Content Types                        â”‚
â”‚  â€¢ Media Library                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Why Two Layers?

### The Problem

**Monolithic approach** mixes concerns:

```tsx
// âŒ Bad: Everything mixed together
export default async function Page() {
  // Data fetching
  const response = await fetch('http://localhost:1337/graphql', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query: '...' }),
  });
  const data = await response.json();
  
  // Cache management
  revalidateTag('articles');
  
  // Presentation logic
  return (
    <div>
      <img src={data.image.url} alt={data.image.alt} />
    </div>
  );
}
```

**Issues**:
- ğŸ”´ Tight coupling
- ğŸ”´ Code duplication
- ğŸ”´ Hard to test
- ğŸ”´ Difficult to maintain

### The Solution

**Layered approach** separates concerns:

```tsx
// âœ… Good: Clean separation
// Data Layer
const data = await strapi.getPage('home', GetHomePageDocument);

// Presentation Layer
return <StrapiImage data={data.image} />;
```

**Benefits**:
- âœ… Loose coupling
- âœ… Reusable components
- âœ… Easy to test
- âœ… Maintainable

## Layer 1: Data Layer

### Responsibilities

The data layer handles:

1. **Data Fetching** - GraphQL queries to Strapi
2. **Type Safety** - TypeScript type generation
3. **Caching** - Automatic cache management
4. **Authentication** - API token handling
5. **Error Handling** - Network and API errors

### Core Components

#### createStrapiSDK

The main entry point for data fetching:

```ts filename="lib/strapi.ts"
import { createStrapiSDK } from 'strapi-nextgen-framework';

export const strapi = createStrapiSDK({
  url: process.env.NEXT_PUBLIC_STRAPI_GRAPHQL_URL!,
  token: process.env.STRAPI_API_TOKEN,
  logging: {
    queries: process.env.NODE_ENV === 'development',
  },
});
```

**Features**:
- Automatic cache tag generation
- Draft mode integration
- Type-safe queries
- Error handling

#### SDK Methods

```ts
// Fetch single page
const page = await strapi.getPage('home', GetHomePageDocument);

// Fetch collection
const articles = await strapi.getCollection('articles', GetArticlesDocument);

// Fetch global data
const global = await strapi.getGlobal('header', GetHeaderDocument);

// Raw query (full control)
const custom = await strapi.rawQuery(CustomDocument, variables);
```

#### Cache Management

Automatic cache tagging:

```ts
// Automatically tagged with 'page-home'
const home = await strapi.getPage('home', GetHomePageDocument);

// Automatically tagged with 'articles'
const articles = await strapi.getCollection('articles', GetArticlesDocument);

// Revalidate specific tag
revalidateTag('articles');
```

### File Structure

```
src/
â”œâ”€â”€ sdk/
â”‚   â”œâ”€â”€ index.ts              # SDK creation & main API
â”‚   â”œâ”€â”€ cache-tags.ts         # Cache tag generation
â”‚   â”œâ”€â”€ fetch-wrapper.ts      # GraphQL client wrapper
â”‚   â””â”€â”€ types.ts              # TypeScript types
```

## Layer 2: Presentation Layer

### Responsibilities

The presentation layer handles:

1. **Rendering** - React components for UI
2. **Error Boundaries** - Graceful error handling
3. **Validation** - Zod schema validation
4. **Optimization** - Image optimization, lazy loading
5. **Accessibility** - WCAG compliance

### Core Components

#### StrapiImage

Optimized image rendering:

```tsx
<StrapiImage
  data={imageData}
  nextImageProps={{
    priority: true,
    className: "rounded-lg",
  }}
/>
```

**Features**:
- Next.js Image optimization
- Automatic responsive images
- Accessibility (alt text)
- Error handling

#### StrapiRenderer

Dynamic component rendering:

```tsx
<StrapiRenderer
  sections={page.sections}
  componentMap={componentMap}
  fallback={<DefaultSection />}
/>
```

**Features**:
- Dynamic zone rendering
- Error boundaries per component
- Type-safe component mapping
- Fallback support

#### ComponentErrorBoundary

Error isolation:

```tsx
<ComponentErrorBoundary componentType="sections.hero">
  <HeroSection {...props} />
</ComponentErrorBoundary>
```

**Features**:
- Development error UI
- Production graceful degradation
- Error logging
- Component isolation

### File Structure

```
src/
â”œâ”€â”€ components/
â”‚   â””â”€â”€ StrapiImage.tsx       # Image component
â”œâ”€â”€ renderer/
â”‚   â”œâ”€â”€ index.tsx             # StrapiRenderer
â”‚   â”œâ”€â”€ error-boundary.tsx    # Error boundaries
â”‚   â”œâ”€â”€ validator.ts          # Zod validation
â”‚   â””â”€â”€ types.ts              # TypeScript types
```

## Supporting Layers

### Helpers Layer

Utility functions that bridge both layers:

#### Metadata Generation

```ts
import { generateStrapiMetadata } from 'strapi-nextgen-framework';

export async function generateMetadata() {
  const data = await strapi.getPage('home', GetHomePageDocument);
  return generateStrapiMetadata(data.seo);
}
```

#### Preview Mode

```ts
import { createPreviewHandler } from 'strapi-nextgen-framework';

const handler = createPreviewHandler({
  secret: process.env.PREVIEW_SECRET!,
});
```

#### Revalidation

```ts
import { createStrapiRevalidator } from 'strapi-nextgen-framework';

const handler = createStrapiRevalidator({
  secret: process.env.REVALIDATION_SECRET!,
  tagMap: {
    'api::article.article': 'articles',
  },
});
```

### File Structure

```
src/
â”œâ”€â”€ helpers/
â”‚   â””â”€â”€ metadata.ts           # SEO metadata
â”œâ”€â”€ preview/
â”‚   â””â”€â”€ index.ts              # Preview handlers
â””â”€â”€ revalidation/
    â””â”€â”€ index.ts              # Revalidation handlers
```

## Complete Architecture

### Full File Structure

```
strapi-nextgen-framework/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/           # Presentation Layer
â”‚   â”‚   â””â”€â”€ StrapiImage.tsx
â”‚   â”œâ”€â”€ renderer/             # Presentation Layer
â”‚   â”‚   â”œâ”€â”€ index.tsx
â”‚   â”‚   â”œâ”€â”€ error-boundary.tsx
â”‚   â”‚   â”œâ”€â”€ validator.ts
â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”œâ”€â”€ sdk/                  # Data Layer
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ cache-tags.ts
â”‚   â”‚   â”œâ”€â”€ fetch-wrapper.ts
â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”œâ”€â”€ helpers/              # Helper Functions
â”‚   â”‚   â””â”€â”€ metadata.ts
â”‚   â”œâ”€â”€ preview/              # Preview Handlers
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ revalidation/         # Revalidation Handlers
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ types/                # Shared Types
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ index.ts              # Public API
â”œâ”€â”€ dist/                     # Build output (CJS + ESM)
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

## Data Flow

### Page Request Flow

```
1. User Request
   â†“
2. Next.js Server Component
   â†“
3. SDK (Data Layer)
   â€¢ Checks cache
   â€¢ If miss, queries GraphQL
   â€¢ Tags with cache key
   â€¢ Returns typed data
   â†“
4. Component (Presentation Layer)
   â€¢ Receives data
   â€¢ Validates with Zod
   â€¢ Renders UI
   â€¢ Handles errors
   â†“
5. HTML Response
```

### Revalidation Flow

```
1. Content Published in Strapi
   â†“
2. Webhook Triggered
   â†“
3. Revalidation Handler
   â€¢ Validates secret
   â€¢ Maps model to cache tag
   â€¢ Calls revalidateTag()
   â†“
4. Next.js Cache Invalidated
   â†“
5. Next Request Fetches Fresh Data
```

## Design Patterns

### 1. Dependency Injection

Components receive dependencies, not create them:

```tsx
// âœ… Good: Dependency injected
function ArticleCard({ data }: { data: Article }) {
  return <div>{data.title}</div>;
}

// âŒ Bad: Fetching inside component
function ArticleCard({ id }: { id: string }) {
  const data = await fetch(...); // Couples component to data source
  return <div>{data.title}</div>;
}
```

### 2. Error Boundary Pattern

Isolate errors to prevent cascade failures:

```tsx
<ComponentErrorBoundary>
  <Section1 />
</ComponentErrorBoundary>
<ComponentErrorBoundary>
  <Section2 />  {/* Section1 error won't break this */}
</ComponentErrorBoundary>
```

### 3. Factory Pattern

SDK creation uses factory pattern:

```ts
// Factory creates configured instance
export const strapi = createStrapiSDK(config);

// All methods use same configuration
strapi.getPage(...);
strapi.getCollection(...);
```

### 4. Adapter Pattern

Adapts Strapi data to Next.js formats:

```ts
// Strapi SEO â†’ Next.js Metadata
export function generateStrapiMetadata(seo: StrapiSEO): Metadata {
  return {
    title: seo?.metaTitle,
    description: seo?.metaDescription,
    // ... adapter logic
  };
}
```

## Extension Points

### Custom SDK Methods

Extend the SDK for your use case:

```ts
import { createStrapiSDK } from 'strapi-nextgen-framework';

const baseSdk = createStrapiSDK({ ... });

// Add custom method
export const strapi = {
  ...baseSdk,
  async getLatestArticles(limit = 10) {
    return baseSdk.getCollection('articles', GetArticlesDocument, {
      pagination: { limit },
      sort: 'publishedAt:desc',
    });
  },
};
```

### Custom Components

Create your own presentation components:

```tsx
import { StrapiMedia } from 'strapi-nextgen-framework';

export function StrapiVideo({ data }: { data: StrapiMedia }) {
  if (!data?.data?.attributes?.url) return null;
  
  return (
    <video src={data.data.attributes.url} controls />
  );
}
```

### Custom Error Boundaries

Wrap with your own error handling:

```tsx
import { ComponentErrorBoundary } from 'strapi-nextgen-framework';

export function CustomErrorBoundary({ children }) {
  return (
    <ComponentErrorBoundary
      fallback={(error) => (
        <YourCustomErrorUI error={error} />
      )}
    >
      {children}
    </ComponentErrorBoundary>
  );
}
```

## Testing Strategy

### Data Layer Testing

Test SDK methods in isolation:

```ts
import { createStrapiSDK } from 'strapi-nextgen-framework';

describe('SDK', () => {
  it('should fetch page data', async () => {
    const sdk = createStrapiSDK({ url: TEST_URL });
    const data = await sdk.getPage('home', GetHomePageDocument);
    
    expect(data.page).toBeDefined();
  });
});
```

### Presentation Layer Testing

Test components with mocked data:

```tsx
import { render } from '@testing-library/react';
import { StrapiImage } from 'strapi-nextgen-framework';

test('renders image', () => {
  const mockData = { url: '/test.jpg', width: 800, height: 600 };
  render(<StrapiImage data={mockData} />);
  
  expect(screen.getByRole('img')).toBeInTheDocument();
});
```

### Integration Testing

Test both layers together:

```tsx
test('page fetches and renders data', async () => {
  const data = await strapi.getPage('home', GetHomePageDocument);
  
  render(<HomePage data={data} />);
  
  expect(screen.getByText(data.page.title)).toBeInTheDocument();
});
```

## Performance Considerations

### 1. Lazy Loading

Presentation components use lazy loading:

```tsx
import dynamic from 'next/dynamic';

const StrapiRenderer = dynamic(() => 
  import('strapi-nextgen-framework').then(mod => mod.StrapiRenderer)
);
```

### 2. Request Deduplication

SDK automatically deduplicates identical requests:

```ts
// Both calls = one request
const data1 = await strapi.getPage('home', GetHomePageDocument);
const data2 = await strapi.getPage('home', GetHomePageDocument);
```

### 3. Parallel Fetching

Fetch independent data in parallel:

```ts
const [page, global] = await Promise.all([
  strapi.getPage('home', GetHomePageDocument),
  strapi.getGlobal('header', GetHeaderDocument),
]);
```

## Security Architecture

### Layer Separation Benefits

1. **Data Layer** - Server-only, can use secrets
2. **Presentation Layer** - Can run client-side safely

```tsx
// âœ… Safe: SDK in server component
export default async function Page() {
  const data = await strapi.getPage('home', GetHomePageDocument);
  // API token never exposed to client
  
  return <StrapiImage data={data.image} />;
  // Component can be client component
}
```

### Secret Management

```ts
// Data layer uses secrets
const strapi = createStrapiSDK({
  token: process.env.STRAPI_API_TOKEN, // Server-only
});

// Presentation layer has no secrets
<StrapiImage data={publicData} />
```

## Best Practices

### 1. Keep Layers Separate

```tsx
// âœ… Data layer
const data = await strapi.getPage('home', GetHomePageDocument);

// âœ… Presentation layer
<StrapiImage data={data.image} />

// âŒ Don't mix
<StrapiImage 
  data={await strapi.getPage('home', GetHomePageDocument).image} 
/>
```

### 2. Use Proper Abstractions

```ts
// âœ… Use SDK methods
await strapi.getPage('home', GetHomePageDocument);

// âŒ Don't bypass
await fetch('http://localhost:1337/graphql', ...);
```

### 3. Handle Errors at Right Layer

```ts
// âœ… Data layer handles fetch errors
try {
  const data = await strapi.getPage('home', GetHomePageDocument);
} catch (error) {
  // Handle data fetching errors
}

// âœ… Presentation layer handles render errors
<ComponentErrorBoundary>
  <Section data={data} />
</ComponentErrorBoundary>
```

## See Also

- [Type Safety Approach](/concepts/type-safety)
- [Caching Strategy](/concepts/caching-strategy)
- [Testing Philosophy](/concepts/testing-philosophy)
- [API Reference](/api-reference)
